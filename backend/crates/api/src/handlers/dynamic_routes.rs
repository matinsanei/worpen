use axum::{
    extract::{State, Path},
    Json,
    http::StatusCode,
};
use crate::state::AppState;
use proto::models::{RouteDefinition, RegisterRouteRequest, RouteTestRequest, RouteTestResponse};
use serde_json::Value;

/// Register a new dynamic route
#[utoipa::path(
    post,
    path = "/api/v1/dynamic-routes",
    request_body = RegisterRouteRequest,
    responses(
        (status = 201, description = "Route registered successfully", body = Value),
        (status = 400, description = "Invalid route definition")
    )
)]
pub async fn register_route(
    State(state): State<AppState>,
    Json(req): Json<RegisterRouteRequest>,
) -> Result<(StatusCode, Json<Value>), (StatusCode, Json<Value>)> {
    // Convert RegisterRouteRequest to RouteDefinition
    let route = RouteDefinition {
        id: String::new(), // Will be generated by service
        name: req.name,
        description: req.description,
        path: req.path,
        method: req.method,
        logic: req.logic,
        parameters: req.parameters,
        response_schema: req.response_schema,
        auth_required: req.auth_required,
        rate_limit: req.rate_limit,
        enabled: req.enabled,
        version: req.version,
        created_at: String::new(), // Will be set by service
        updated_at: String::new(), // Will be set by service
        created_by: "system".to_string(), // Default creator
    };
    match state.dynamic_route_service.register_route(route).await {
        Ok(route_id) => Ok((
            StatusCode::CREATED,
            Json(serde_json::json!({
                "status": "REGISTERED",
                "route_id": route_id,
                "message": "Route registered successfully"
            }))
        )),
        Err(e) => Err((
            StatusCode::BAD_REQUEST,
            Json(serde_json::json!({
                "error": e
            }))
        ))
    }
}

/// List all dynamic routes
#[utoipa::path(
    get,
    path = "/api/v1/dynamic-routes",
    responses(
        (status = 200, description = "List of all routes", body = Vec<RouteDefinition>)
    )
)]
pub async fn list_routes(
    State(state): State<AppState>,
) -> Json<Vec<RouteDefinition>> {
    match state.dynamic_route_service.list_routes().await {
        Ok(routes) => Json(routes),
        Err(_) => Json(vec![]),
    }
}

/// Get a specific route by ID
#[utoipa::path(
    get,
    path = "/api/v1/dynamic-routes/{id}",
    responses(
        (status = 200, description = "Route details", body = RouteDefinition),
        (status = 404, description = "Route not found")
    )
)]
pub async fn get_route(
    State(state): State<AppState>,
    Path(id): Path<String>,
) -> Result<Json<RouteDefinition>, StatusCode> {
    match state.dynamic_route_service.get_route(&id).await {
        Ok(Some(route)) => Ok(Json(route)),
        Ok(None) => Err(StatusCode::NOT_FOUND),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}

/// Update an existing route
#[utoipa::path(
    put,
    path = "/api/v1/dynamic-routes/{id}",
    request_body = RouteDefinition,
    responses(
        (status = 200, description = "Route updated successfully"),
        (status = 404, description = "Route not found")
    )
)]
pub async fn update_route(
    State(state): State<AppState>,
    Path(id): Path<String>,
    Json(route): Json<RouteDefinition>,
) -> Result<Json<Value>, (StatusCode, Json<Value>)> {
    match state.dynamic_route_service.update_route(&id, route).await {
        Ok(_) => Ok(Json(serde_json::json!({
            "status": "UPDATED",
            "route_id": id
        }))),
        Err(e) if e.contains("not found") => Err((
            StatusCode::NOT_FOUND,
            Json(serde_json::json!({"error": e}))
        )),
        Err(e) => Err((
            StatusCode::BAD_REQUEST,
            Json(serde_json::json!({"error": e}))
        ))
    }
}

/// Delete a route
#[utoipa::path(
    delete,
    path = "/api/v1/dynamic-routes/{id}",
    responses(
        (status = 200, description = "Route deleted successfully"),
        (status = 404, description = "Route not found")
    )
)]
pub async fn delete_route(
    State(state): State<AppState>,
    Path(id): Path<String>,
) -> Result<Json<Value>, StatusCode> {
    match state.dynamic_route_service.delete_route(&id).await {
        Ok(_) => Ok(Json(serde_json::json!({
            "status": "DELETED",
            "route_id": id
        }))),
        Err(_) => Err(StatusCode::NOT_FOUND),
    }
}

/// Test a route with test data
#[utoipa::path(
    post,
    path = "/api/v1/dynamic-routes/test",
    request_body = RouteTestRequest,
    responses(
        (status = 200, description = "Test results", body = RouteTestResponse)
    )
)]
pub async fn test_route(
    State(state): State<AppState>,
    Json(request): Json<RouteTestRequest>,
) -> Json<RouteTestResponse> {
    match state.dynamic_route_service.test_route(request).await {
        Ok(response) => Json(response),
        Err(e) => Json(RouteTestResponse {
            success: false,
            result: None,
            error: Some(e),
            execution_time_ms: 0,
            steps_executed: vec![],
        }),
    }
}

/// Execute a dynamic route
#[utoipa::path(
    post,
    path = "/api/v1/dynamic-routes/{id}/execute",
    request_body = Value,
    responses(
        (status = 200, description = "Execution result", body = Value),
        (status = 404, description = "Route not found"),
        (status = 500, description = "Execution failed")
    )
)]
pub async fn execute_route(
    State(state): State<AppState>,
    Path(id): Path<String>,
    Json(payload): Json<Value>,
) -> Result<Json<Value>, (StatusCode, Json<Value>)> {
    match state.dynamic_route_service.execute_route(
        &id,
        Some(payload),
        std::collections::HashMap::new(),
        std::collections::HashMap::new(),
    ).await {
        Ok(result) => Ok(Json(result)),
        Err(e) if e.contains("not found") => Err((
            StatusCode::NOT_FOUND,
            Json(serde_json::json!({"error": e}))
        )),
        Err(e) if e.contains("disabled") => Err((
            StatusCode::FORBIDDEN,
            Json(serde_json::json!({"error": e}))
        )),
        Err(e) => Err((
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(serde_json::json!({"error": e}))
        )),
    }
}

/// Export route as JSON
#[utoipa::path(
    get,
    path = "/api/v1/dynamic-routes/{id}/export",
    responses(
        (status = 200, description = "Route JSON", body = String),
        (status = 404, description = "Route not found")
    )
)]
pub async fn export_route(
    State(state): State<AppState>,
    Path(id): Path<String>,
) -> Result<String, StatusCode> {
    match state.dynamic_route_service.export_route(&id).await {
        Ok(json) => Ok(json),
        Err(_) => Err(StatusCode::NOT_FOUND),
    }
}

/// Import route from JSON
#[utoipa::path(
    post,
    path = "/api/v1/dynamic-routes/import",
    request_body = String,
    responses(
        (status = 201, description = "Route imported successfully", body = Value),
        (status = 400, description = "Invalid JSON")
    )
)]
pub async fn import_route(
    State(state): State<AppState>,
    body: String,
) -> Result<(StatusCode, Json<Value>), (StatusCode, Json<Value>)> {
    match state.dynamic_route_service.import_route(&body).await {
        Ok(route_id) => Ok((
            StatusCode::CREATED,
            Json(serde_json::json!({
                "status": "IMPORTED",
                "route_id": route_id
            }))
        )),
        Err(e) => Err((
            StatusCode::BAD_REQUEST,
            Json(serde_json::json!({"error": e}))
        ))
    }
}

/// Get route statistics
#[utoipa::path(
    get,
    path = "/api/v1/dynamic-routes/stats",
    responses(
        (status = 200, description = "Route statistics", body = Value)
    )
)]
pub async fn get_route_stats(
    State(state): State<AppState>,
) -> Json<Value> {
    match state.dynamic_route_service.list_routes().await {
        Ok(routes) => {
            let total = routes.len();
            let enabled = routes.iter().filter(|r| r.enabled).count();
            let disabled = total - enabled;
            
            let by_method: std::collections::HashMap<String, usize> = routes.iter()
                .map(|r| format!("{:?}", r.method))
                .fold(std::collections::HashMap::new(), |mut acc, method| {
                    *acc.entry(method).or_insert(0) += 1;
                    acc
                });
            
            Json(serde_json::json!({
                "total_routes": total,
                "enabled_routes": enabled,
                "disabled_routes": disabled,
                "routes_by_method": by_method,
            }))
        },
        Err(_) => Json(serde_json::json!({
            "total_routes": 0,
            "enabled_routes": 0,
            "disabled_routes": 0,
            "routes_by_method": {},
        })),
    }
}
