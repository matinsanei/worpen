//! Enhanced dynamic routes handlers with YAML support

use axum::{
    extract::State,
    Json,
    http::{StatusCode, HeaderMap},
    body::Bytes,
};
use crate::state::AppState;
use proto::models::RouteDefinition;
use serde_json::Value;
use core::parsers::{parse_route, detect_format, InputFormat};

/// Register a new dynamic route (YAML/JSON auto-detect)
/// 
/// Accepts both JSON and YAML formats with automatic format detection.
/// Format can also be explicitly specified via Content-Type header:
/// - application/json → Force JSON parsing
/// - application/x-yaml or text/yaml → Force YAML parsing
/// - (no header or other) → Auto-detect from content
#[utoipa::path(
    post,
    path = "/api/v1/dynamic-routes/register",
    request_body = String,
    responses(
        (status = 201, description = "Route registered successfully", body = Value),
        (status = 400, description = "Invalid route definition")
    )
)]
pub async fn register_route_raw(
    State(state): State<AppState>,
    headers: HeaderMap,
    body: Bytes,
) -> Result<(StatusCode, Json<Value>), (StatusCode, Json<Value>)> {
    // Convert body to string
    let content = String::from_utf8(body.to_vec())
        .map_err(|e| (
            StatusCode::BAD_REQUEST,
            Json(serde_json::json!({
                "error": "Invalid UTF-8 in request body",
                "details": e.to_string()
            }))
        ))?;

    // Detect or use explicit format from Content-Type header
    let format = if let Some(content_type) = headers.get("content-type") {
        let ct_str = content_type.to_str().unwrap_or("");
        if ct_str.contains("yaml") || ct_str.contains("yml") {
            InputFormat::Yaml
        } else if ct_str.contains("json") {
            InputFormat::Json
        } else {
            detect_format(&content)
        }
    } else {
        detect_format(&content)
    };

    // Parse route
    let req = parse_route(&content)
        .map_err(|e| (
            StatusCode::BAD_REQUEST,
            Json(serde_json::json!({
                "error": "Parse error",
                "details": e,
                "detected_format": format!("{:?}", format)
            }))
        ))?;

    // Convert RegisterRouteRequest to RouteDefinition
    let route = RouteDefinition {
        id: String::new(), // Will be generated by service
        name: req.name.clone(),
        description: req.description.clone(),
        path: req.path.clone(),
        method: req.method.clone(),
        logic: req.logic.clone(),
        parameters: req.parameters.clone(),
        response_schema: req.response_schema.clone(),
        auth_required: req.auth_required,
        rate_limit: req.rate_limit,
        enabled: req.enabled,
        version: req.version.clone(),
        created_at: String::new(), // Will be set by service
        updated_at: String::new(), // Will be set by service
        created_by: "system".to_string(), // Default creator
    };

    match state.dynamic_route_service.register_route(route).await {
        Ok(route_id) => Ok((
            StatusCode::CREATED,
            Json(serde_json::json!({
                "status": "REGISTERED",
                "route_id": route_id,
                "route_name": req.name,
                "format": format!("{:?}", format),
                "message": "Route registered successfully"
            }))
        )),
        Err(e) => Err((
            StatusCode::BAD_REQUEST,
            Json(serde_json::json!({
                "error": e
            }))
        ))
    }
}

/// Get format statistics
#[utoipa::path(
    get,
    path = "/api/v1/dynamic-routes/formats",
    responses(
        (status = 200, description = "Format usage statistics", body = Value)
    )
)]
pub async fn get_format_stats(
    State(state): State<AppState>,
) -> Json<Value> {
    match state.dynamic_route_service.list_routes().await {
        Ok(routes) => {
            let total = routes.len();
            
            Json(serde_json::json!({
                "total_routes": total,
                "supported_formats": ["JSON", "YAML"],
                "features": {
                    "auto_detection": true,
                    "explicit_content_type": true,
                    "yaml_comments": true,
                    "yaml_multiline": true
                }
            }))
        },
        Err(_) => Json(serde_json::json!({
            "total_routes": 0,
            "supported_formats": ["JSON", "YAML"]
        })),
    }
}
